(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{180:function(t,a,n){"use strict";n.r(a);var s=n(0),e=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"java8系列：函数接口之predicate"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java8系列：函数接口之predicate","aria-hidden":"true"}},[t._v("#")]),t._v(" java8系列：函数接口之Predicate")]),t._v(" "),n("p",[t._v("Predicate函数式接口的主要作用就是提供一个test方法，接受一个参数返回一个布尔类型，即判断输入的对象是否符合某个条件。")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{attrs:{class:"token keyword"}},[t._v("package")]),t._v(" java"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("util"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("function"),n("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{attrs:{class:"token keyword"}},[t._v("import")]),t._v(" java"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("util"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Objects"),n("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{attrs:{class:"token comment"}},[t._v('/**\n * Represents a predicate (boolean-valued function) of one argument.\n *\n * <p>This is a <a href="package-summary.html">functional interface</a>\n * whose functional method is {@link #test(Object)}.\n *\n * @param <T> the type of the input to the predicate\n *\n * @since 1.8\n */')]),t._v("\n"),n("span",{attrs:{class:"token annotation punctuation"}},[t._v("@FunctionalInterface")]),t._v("\n"),n("span",{attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),n("span",{attrs:{class:"token class-name"}},[t._v("Predicate")]),n("span",{attrs:{class:"token generics function"}},[n("span",{attrs:{class:"token punctuation"}},[t._v("<")]),t._v("T"),n("span",{attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),n("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n    "),n("span",{attrs:{class:"token comment"}},[t._v("/**\n     * Evaluates this predicate on the given argument.\n     *\n     * @param t the input argument\n     * @return {@code true} if the input argument matches the predicate,\n     * otherwise {@code false}\n     */")]),t._v("\n    "),n("span",{attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),n("span",{attrs:{class:"token function"}},[t._v("test")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("T t"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),n("span",{attrs:{class:"token comment"}},[t._v("/**\n     * Returns a composed predicate that represents a short-circuiting logical\n     * AND of this predicate and another.  When evaluating the composed\n     * predicate, if this predicate is {@code false}, then the {@code other}\n     * predicate is not evaluated.\n     *\n     * <p>Any exceptions thrown during evaluation of either predicate are relayed\n     * to the caller; if evaluation of this predicate throws an exception, the\n     * {@code other} predicate will not be evaluated.\n     *\n     * @param other a predicate that will be logically-ANDed with this\n     *              predicate\n     * @return a composed predicate that represents the short-circuiting logical\n     * AND of this predicate and the {@code other} predicate\n     * @throws NullPointerException if other is null\n     */")]),t._v("\n    "),n("span",{attrs:{class:"token keyword"}},[t._v("default")]),t._v(" Predicate"),n("span",{attrs:{class:"token generics function"}},[n("span",{attrs:{class:"token punctuation"}},[t._v("<")]),t._v("T"),n("span",{attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),n("span",{attrs:{class:"token function"}},[t._v("and")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Predicate"),n("span",{attrs:{class:"token operator"}},[t._v("<")]),n("span",{attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),n("span",{attrs:{class:"token keyword"}},[t._v("super")]),t._v(" T"),n("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v(" other"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        Objects"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{attrs:{class:"token function"}},[t._v("requireNonNull")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("other"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),n("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{attrs:{class:"token operator"}},[t._v("-")]),n("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),n("span",{attrs:{class:"token function"}},[t._v("test")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{attrs:{class:"token operator"}},[t._v("&&")]),t._v(" other"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{attrs:{class:"token function"}},[t._v("test")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),n("span",{attrs:{class:"token comment"}},[t._v("/**\n     * Returns a predicate that represents the logical negation of this\n     * predicate.\n     *\n     * @return a predicate that represents the logical negation of this\n     * predicate\n     */")]),t._v("\n    "),n("span",{attrs:{class:"token keyword"}},[t._v("default")]),t._v(" Predicate"),n("span",{attrs:{class:"token generics function"}},[n("span",{attrs:{class:"token punctuation"}},[t._v("<")]),t._v("T"),n("span",{attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),n("span",{attrs:{class:"token function"}},[t._v("negate")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{attrs:{class:"token operator"}},[t._v("-")]),n("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),n("span",{attrs:{class:"token operator"}},[t._v("!")]),n("span",{attrs:{class:"token function"}},[t._v("test")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),n("span",{attrs:{class:"token comment"}},[t._v("/**\n     * Returns a composed predicate that represents a short-circuiting logical\n     * OR of this predicate and another.  When evaluating the composed\n     * predicate, if this predicate is {@code true}, then the {@code other}\n     * predicate is not evaluated.\n     *\n     * <p>Any exceptions thrown during evaluation of either predicate are relayed\n     * to the caller; if evaluation of this predicate throws an exception, the\n     * {@code other} predicate will not be evaluated.\n     *\n     * @param other a predicate that will be logically-ORed with this\n     *              predicate\n     * @return a composed predicate that represents the short-circuiting logical\n     * OR of this predicate and the {@code other} predicate\n     * @throws NullPointerException if other is null\n     */")]),t._v("\n    "),n("span",{attrs:{class:"token keyword"}},[t._v("default")]),t._v(" Predicate"),n("span",{attrs:{class:"token generics function"}},[n("span",{attrs:{class:"token punctuation"}},[t._v("<")]),t._v("T"),n("span",{attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),n("span",{attrs:{class:"token function"}},[t._v("or")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Predicate"),n("span",{attrs:{class:"token operator"}},[t._v("<")]),n("span",{attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),n("span",{attrs:{class:"token keyword"}},[t._v("super")]),t._v(" T"),n("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v(" other"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        Objects"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{attrs:{class:"token function"}},[t._v("requireNonNull")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("other"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),n("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{attrs:{class:"token operator"}},[t._v("-")]),n("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),n("span",{attrs:{class:"token function"}},[t._v("test")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{attrs:{class:"token operator"}},[t._v("||")]),t._v(" other"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{attrs:{class:"token function"}},[t._v("test")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),n("span",{attrs:{class:"token comment"}},[t._v("/**\n     * Returns a predicate that tests if two arguments are equal according\n     * to {@link Objects#equals(Object, Object)}.\n     *\n     * @param <T> the type of arguments to the predicate\n     * @param targetRef the object reference with which to compare for equality,\n     *               which may be {@code null}\n     * @return a predicate that tests if two arguments are equal according\n     * to {@link Objects#equals(Object, Object)}\n     */")]),t._v("\n    "),n("span",{attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),n("span",{attrs:{class:"token generics function"}},[n("span",{attrs:{class:"token punctuation"}},[t._v("<")]),t._v("T"),n("span",{attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" Predicate"),n("span",{attrs:{class:"token generics function"}},[n("span",{attrs:{class:"token punctuation"}},[t._v("<")]),t._v("T"),n("span",{attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),n("span",{attrs:{class:"token function"}},[t._v("isEqual")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Object targetRef"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("null "),n("span",{attrs:{class:"token operator"}},[t._v("==")]),t._v(" targetRef"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n                "),n("span",{attrs:{class:"token operator"}},[t._v("?")]),t._v(" Objects"),n("span",{attrs:{class:"token operator"}},[t._v(":")]),n("span",{attrs:{class:"token operator"}},[t._v(":")]),t._v("isNull\n                "),n("span",{attrs:{class:"token operator"}},[t._v(":")]),t._v(" object "),n("span",{attrs:{class:"token operator"}},[t._v("-")]),n("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v(" targetRef"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{attrs:{class:"token function"}},[t._v("equals")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("object"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),n("h2",{attrs:{id:"方法详解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方法详解","aria-hidden":"true"}},[t._v("#")]),t._v(" 方法详解")]),t._v(" "),n("p",[t._v("在Predicate接口中，总共有5个方法，除了test()是抽象方法外，其他为默认方法和静态方法。")]),t._v(" "),n("div",{staticClass:"tip custom-block"},[n("p",{staticClass:"custom-block-title"},[t._v("其他方法说明")]),t._v(" "),n("ul",[n("li",[t._v("test：判断输入的对象是否符合某个条件，满足条件返回true，否则返回false。")]),t._v(" "),n("li",[t._v("and: 将多个函数接口组合成一个新的函数接口，并且多个函数是并且的关系。")]),t._v(" "),n("li",[t._v("or: 将多个函数接口组合成一个新的函数接口，并且多个函数是或的关系。")]),t._v(" "),n("li",[t._v("negate：取反，构造当前predicate函数的取反函数")]),t._v(" "),n("li",[t._v("isEqual：判断两个对象是否相等，等价于Objects.equals(obj2,obj2)")])])]),t._v(" "),n("h2",{attrs:{id:"案例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#案例","aria-hidden":"true"}},[t._v("#")]),t._v(" 案例")]),t._v(" "),n("h3",{attrs:{id:"需求"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#需求","aria-hidden":"true"}},[t._v("#")]),t._v(" 需求")]),t._v(" "),n("p",[t._v("有一框苹果，")]),t._v(" "),n("h3",{attrs:{id:"编写代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#编写代码","aria-hidden":"true"}},[t._v("#")]),t._v(" 编写代码")])])}],!1,null,null,null);e.options.__file="java8-01-predicate.md";a.default=e.exports}}]);